name: _Release Browser (Reusable)

on:
  workflow_call:
    inputs:
      channel:
        required: true
        type: string
      new-cycle:
        required: false
        type: boolean
        default: false
    secrets:
      NUCLEO_LICENSE_KEY:
        required: false
      POSTHOG_API_KEY:
        required: false
      VITE_POSTHOG_API_KEY:
        required: false
      APPLE_ID:
        required: false
      APPLE_PASSWORD:
        required: false
      APPLE_TEAM_ID:
        required: false
      APPLE_SIGNING_IDENTITY:
        required: false
      MACOS_CERT_P12_BASE64:
        required: false
      MACOS_CERT_P12_PASSWORD:
        required: false
      # Azure Trusted Signing secrets (Windows code signing)
      AZURE_TENANT_ID:
        required: false
      AZURE_CLIENT_ID:
        required: false
      AZURE_CLIENT_SECRET:
        required: false
      AZURE_ACCOUNT_NAME:
        required: false
      AZURE_ACCOUNT_ENDPOINT_URI:
        required: false
      AZURE_CERTIFICATE_PROFILE_NAME:
        required: false

jobs:
  version-bump:
    runs-on: ubuntu-latest
    permissions:
      contents: write
    outputs:
      version: ${{ steps.bump.outputs.version }}
      tag: ${{ steps.bump.outputs.tag }}
      notes: ${{ steps.bump.outputs.notes }}
    env:
      NUCLEO_LICENSE_KEY: ${{ secrets.NUCLEO_LICENSE_KEY }}

    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - uses: pnpm/action-setup@v4
        with:
          version: 10.27.0

      - uses: actions/setup-node@v4
        with:
          node-version: 22
          cache: 'pnpm'

      - run: pnpm install --frozen-lockfile

      - name: Bump Version
        id: bump
        run: |
          ARGS="--package stagewise --channel ${{ inputs.channel }}"
          [ "${{ inputs.new-cycle }}" == "true" ] && ARGS="$ARGS --new-cycle"
          pnpm tsx scripts/release/index.ts $ARGS
          echo "version=$(cat .release-version)" >> $GITHUB_OUTPUT
          echo "tag=$(cat .release-tag)" >> $GITHUB_OUTPUT
          echo "notes<<EOF" >> $GITHUB_OUTPUT
          cat .release-notes.md >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      - name: Commit and Tag
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git add .
          git commit -m "chore(stagewise): release ${{ steps.bump.outputs.version }} [skip ci]"
          git push
          git tag ${{ steps.bump.outputs.tag }}
          git push origin ${{ steps.bump.outputs.tag }}

  build:
    needs: version-bump
    environment: Release
    strategy:
      fail-fast: false
      matrix:
        include:
          - os: macos-26
            arch: arm64
            artifact: stagewise-macos-arm64
          - os: ubuntu-latest
            arch: x64
            artifact: stagewise-linux-x64
          - os: windows-latest
            arch: x64
            artifact: stagewise-windows-x64

    runs-on: ${{ matrix.os }}
    permissions:
      contents: write

    env:
      NODE_OPTIONS: "--max-old-space-size=8192"
      NUCLEO_LICENSE_KEY: ${{ secrets.NUCLEO_LICENSE_KEY }}
      POSTHOG_API_KEY: ${{ secrets.POSTHOG_API_KEY }}
      VITE_POSTHOG_API_KEY: ${{ secrets.VITE_POSTHOG_API_KEY }}
      API_URL: ${{ vars.API_URL }}
      VITE_API_URL: ${{ vars.VITE_API_URL }}
      STAGEWISE_CONSOLE_URL: ${{ vars.STAGEWISE_CONSOLE_URL }}
      VITE_STAGEWISE_CONSOLE_URL: ${{ vars.VITE_STAGEWISE_CONSOLE_URL }}
      LLM_PROXY_URL: ${{ vars.LLM_PROXY_URL }}
      VITE_DISABLE_TELEMETRY: ${{ vars.VITE_DISABLE_TELEMETRY }}

    steps:
      - uses: actions/checkout@v4
        with:
          ref: ${{ needs.version-bump.outputs.tag }}

      - uses: pnpm/action-setup@v4
        with:
          version: 10.27.0

      - uses: actions/setup-node@v4
        with:
          node-version: 22
          cache: 'pnpm'

      - run: pnpm install --frozen-lockfile

      - name: Import macOS signing certs
        if: runner.os == 'macOS'
        uses: apple-actions/import-codesign-certs@v3
        with:
          p12-file-base64: ${{ secrets.MACOS_CERT_P12_BASE64 }}
          p12-password: ${{ secrets.MACOS_CERT_P12_PASSWORD }}

      - name: Setup Windows code signing
        if: runner.os == 'Windows'
        shell: pwsh
        run: |
          # Install Azure.CodeSigning.Dlib via NuGet
          $nugetDir = "${{ runner.temp }}\nuget"
          New-Item -ItemType Directory -Force -Path $nugetDir | Out-Null

          Write-Host "Installing Microsoft.Trusted.Signing.Client NuGet package..."
          nuget install Microsoft.Trusted.Signing.Client -OutputDirectory $nugetDir -Source https://api.nuget.org/v3/index.json

          # Find the installed dlib
          $dlibPath = Get-ChildItem -Path $nugetDir -Recurse -Filter "Azure.CodeSigning.Dlib.dll" |
            Where-Object { $_.FullName -match "x64" } |
            Select-Object -First 1 -ExpandProperty FullName

          if (-not $dlibPath) {
            Write-Error "Failed to find Azure.CodeSigning.Dlib.dll"
            exit 1
          }
          Write-Host "Found DLIB at: $dlibPath"

          # Find signtool.exe from Windows SDK
          $sdkPath = "C:\Program Files (x86)\Windows Kits\10\bin"
          $signtoolPath = Get-ChildItem -Path $sdkPath -Recurse -Filter "signtool.exe" |
            Where-Object { $_.FullName -match "x64" } |
            Sort-Object { [version]($_.Directory.Parent.Name -replace '^(\d+\.\d+\.\d+\.\d+).*', '$1') } -Descending |
            Select-Object -First 1 -ExpandProperty FullName

          if (-not $signtoolPath) {
            Write-Error "Failed to find signtool.exe in Windows SDK"
            exit 1
          }
          Write-Host "Found signtool.exe at: $signtoolPath"

          # Create metadata.json for Azure Trusted Signing
          $metadataPath = "${{ runner.temp }}\metadata.json"
          $metadata = @{
            Endpoint = "${{ secrets.AZURE_ACCOUNT_ENDPOINT_URI }}"
            CodeSigningAccountName = "${{ secrets.AZURE_ACCOUNT_NAME }}"
            CertificateProfileName = "${{ secrets.AZURE_CERTIFICATE_PROFILE_NAME }}"
          } | ConvertTo-Json

          Set-Content -Path $metadataPath -Value $metadata
          Write-Host "Created metadata.json at: $metadataPath"
          Write-Host "Metadata content:"
          Get-Content $metadataPath

          # Export environment variables for subsequent steps
          echo "SIGNTOOL_PATH=$signtoolPath" >> $env:GITHUB_ENV
          echo "AZURE_CODE_SIGNING_DLIB=$dlibPath" >> $env:GITHUB_ENV
          echo "AZURE_METADATA_JSON=$metadataPath" >> $env:GITHUB_ENV

      - run: pnpm build

      - name: Build Electron App
        working-directory: apps/browser
        run: pnpm make --arch=${{ matrix.arch }}
        env:
          BUILD_MODE: production
          # macOS signing
          APPLE_ID: ${{ secrets.APPLE_ID }}
          APPLE_PASSWORD: ${{ secrets.APPLE_PASSWORD }}
          APPLE_TEAM_ID: ${{ secrets.APPLE_TEAM_ID }}
          APPLE_SIGNING_IDENTITY: ${{ secrets.APPLE_SIGNING_IDENTITY }}
          # Windows signing (Azure Trusted Signing authentication)
          AZURE_TENANT_ID: ${{ secrets.AZURE_TENANT_ID }}
          AZURE_CLIENT_ID: ${{ secrets.AZURE_CLIENT_ID }}
          AZURE_CLIENT_SECRET: ${{ secrets.AZURE_CLIENT_SECRET }}
          # Release channel
          RELEASE_CHANNEL: ${{ inputs.channel == 'release' && 'release' || 'prerelease' }}

      - name: List build output
        working-directory: apps/browser
        run: find out -type f \( -name "*.dmg" -o -name "*.exe" -o -name "*.nupkg" -o -name "RELEASES*" -o -name "*.deb" -o -name "*.rpm" -o -name "*.zip" \) 2>/dev/null || true
        shell: bash

      - uses: actions/upload-artifact@v4
        with:
          name: ${{ matrix.artifact }}
          path: apps/browser/out/*/make/
          if-no-files-found: warn

  release:
    needs: [version-bump, build]
    runs-on: ubuntu-latest
    permissions:
      contents: write

    steps:
      - uses: actions/download-artifact@v4
        with:
          path: artifacts

      - name: Collect Artifacts
        run: |
          mkdir -p release

          echo "Found artifacts:"
          find artifacts -type f

          # Copy all release files to flat directory
          find artifacts -type f \( -name "*.dmg" -o -name "*.exe" -o -name "*.nupkg" -o -name "RELEASES*" -o -name "*.deb" -o -name "*.rpm" -o -name "*.zip" \) -exec cp {} release/ \;

          echo "Release artifacts:"
          ls -la release/

      - uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ needs.version-bump.outputs.tag }}
          name: "Stagewise ${{ needs.version-bump.outputs.version }}"
          body: ${{ needs.version-bump.outputs.notes }}
          prerelease: ${{ inputs.channel != 'release' }}
          files: release/*
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
